<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>Smart Wait — Continuous & Persistent Connections</title>
    <link rel="stylesheet" href="design-system.css">
    <style>
        .btn-start { background: var(--accent); }
        .btn-stop { background: var(--error); }
        .btn-teal { background: #0d9488; box-shadow: 0 1px 3px rgba(13,148,136,0.25); }
        .btn-orange { background: #ea580c; box-shadow: 0 1px 3px rgba(234,88,12,0.25); }
        .btn-blue { background: var(--accent-secondary); box-shadow: 0 1px 3px rgba(99,102,241,0.25); }
    </style>
</head>
<body class="has-monitor">
<script>(function(){var t=localStorage.getItem('lt-theme')||(window.matchMedia('(prefers-color-scheme:light)').matches?'light':'dark');document.documentElement.setAttribute('data-theme',t);})();</script>
<!-- INPUT VALUE MONITOR BAR -->
<div id="inputMonitorBar">
    <span class="monitor-title">Input Monitor</span>
    <div class="monitor-divider"></div>
    <div class="monitor-field">
        <span class="monitor-label">Active:</span>
        <span class="monitor-element-id" id="monitorActiveField">—</span>
    </div>
    <div class="monitor-divider"></div>
    <div class="monitor-field">
        <span class="monitor-label">Event Value:</span>
        <span class="monitor-value" id="monitorEventValue">—</span>
    </div>
    <div class="monitor-divider"></div>
    <div class="monitor-field">
        <span class="monitor-label">.value:</span>
        <span class="monitor-value" id="monitorDomValue">—</span>
    </div>
    <div class="monitor-divider"></div>
    <div class="monitor-field">
        <span class="monitor-label">Source:</span>
        <span class="monitor-source" id="monitorSource">—</span>
    </div>
    <div class="monitor-divider"></div>
    <div class="monitor-field">
        <span class="monitor-label">Keys:</span>
        <span class="monitor-value" id="monitorKeyLog" style="max-width:200px;">—</span>
    </div>
    <div class="monitor-divider" id="monitorGroupDivider" style="display:none;"></div>
    <div class="monitor-field" id="monitorGroupSection" style="display:none;">
        <span class="monitor-group-label" id="monitorGroupLabel">—</span>
        <span class="monitor-value group-val" id="monitorGroupValue">—</span>
    </div>
</div>

<div class="glow-container"><div class="glow-inner"></div></div>
<div class="glow-container glow-2"><div class="glow-inner"></div></div>

<header class="site-header">
    <div class="header-inner">
        <a href="index.html" class="logo">
            <div class="logo-icon">LT</div>
            <div class="logo-text">Continuous Pings</div>
        </a>
        <nav class="header-nav">
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                <span class="icon-sun">&#9728;</span>
                <span class="icon-moon">&#9790;</span>
            </button>
        </nav>
    </div>
</header>

    <main class="container-narrow">
        <div class="page-hero">
            <h1>Smart Wait &mdash; Continuous &amp; Persistent Connections</h1>
            <p class="subtitle">Fetch pings, XHR polling, WebSocket, SSE, Long Polling &amp; Kitchen Sink</p>
        </div>

        <!-- ===================== SECTION 1: Analytics Pings (fetch) ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>1. Continuous Analytics Pings (fetch every 500ms)</h2></div>
            <div class="info-box">
                Simulates analytics beacons via fetch() every 500ms. Smart wait should NOT
                block indefinitely — these are "background noise" requests.
            </div>
            <span id="ping1Status" class="status-badge active">Active</span>
            <p class="counter" id="ping1Count">Pings sent: 0</p>
            <button class="btn-start" onclick="startFetchPings()">Start Pings</button>
            <button class="btn-stop danger" onclick="stopFetchPings()">Stop Pings</button>
            <label for="ping1Input">Type here while pings are active:</label>
            <input type="text" id="ping1Input" placeholder="Should work despite continuous pings">
            <button class="btn-start" id="ping1ActionBtn">Click Me (during pings)</button>
            <div class="log-box" id="log1"></div>
        </div>

        <!-- ===================== SECTION 2: XHR Polling ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>2. XHR Polling (XMLHttpRequest every 1s)</h2></div>
            <div class="info-box">
                Uses old-style XMLHttpRequest polling every 1s. Smart wait should handle
                XHR the same as fetch — not block on continuous polls.
            </div>
            <span id="xhrStatus" class="status-badge active">Active</span>
            <p class="counter" id="xhrCount">Polls: 0</p>
            <button class="btn-orange" onclick="startXhrPolling()">Start XHR Poll</button>
            <button class="btn-stop danger" onclick="stopXhrPolling()">Stop XHR Poll</button>
            <label for="xhrInput">Type here while XHR polls:</label>
            <input type="text" id="xhrInput" placeholder="Should work despite XHR polling">
            <div class="log-box" id="log2"></div>
        </div>

        <!-- ===================== SECTION 3: Beacon API ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>3. Navigator.sendBeacon (fire-and-forget)</h2></div>
            <div class="info-box">
                Uses navigator.sendBeacon() — fire-and-forget requests with no response.
                Smart wait should not track these at all (no response expected).
            </div>
            <p class="counter" id="beaconCount">Beacons sent: 0</p>
            <button class="btn-start" onclick="startBeacons()">Start Beacons</button>
            <button class="btn-stop danger" onclick="stopBeacons()">Stop Beacons</button>
            <label for="beaconInput">Type here while beacons fire:</label>
            <input type="text" id="beaconInput" placeholder="Should work — beacons are fire-and-forget">
            <div class="log-box" id="log3"></div>
        </div>

        <!-- ===================== SECTION 4: WebSocket ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>4. WebSocket (persistent connection + pings)</h2></div>
            <div class="info-box">
                Active WebSocket with periodic ping frames every 2s.
                Smart wait should NOT count WebSocket frames as pending HTTP requests.
            </div>
            <span id="wsStatus" class="status-badge stopped">Disconnected</span>
            <button class="btn-teal" onclick="connectWs()">Connect</button>
            <button class="btn-stop danger" onclick="closeWs()">Disconnect</button>
            <label for="wsInput">Type here while WebSocket is active:</label>
            <input type="text" id="wsInput" placeholder="Should work despite active WebSocket">
            <button class="btn-teal" onclick="sendWsMsg()">Send WS Message</button>
            <div class="log-box" id="log4"></div>
        </div>

        <!-- ===================== SECTION 5: Server-Sent Events (SSE) ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>5. Server-Sent Events (SSE / EventSource)</h2></div>
            <div class="info-box">
                SSE connection receives server-pushed events. Smart wait should NOT count
                the open SSE connection as a pending request.
            </div>
            <span id="sseStatus" class="status-badge stopped">Disconnected</span>
            <p class="counter" id="sseCount">Events received: 0</p>
            <button class="btn-teal" onclick="connectSse()">Connect SSE</button>
            <button class="btn-stop danger" onclick="closeSse()">Close SSE</button>
            <label for="sseInput">Type here while SSE is active:</label>
            <input type="text" id="sseInput" placeholder="Should work despite SSE stream">
            <div class="log-box" id="log5"></div>
        </div>

        <!-- ===================== SECTION 6: Long Polling ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>6. Long Polling (request held open for 5s)</h2></div>
            <div class="info-box">
                Simulates long-polling: request is held open for 5s, then on response,
                immediately issues another. Always one pending request.
            </div>
            <span id="lpStatus" class="status-badge stopped">Inactive</span>
            <p class="counter" id="lpCount">Polls: 0</p>
            <button class="btn-orange" onclick="startLongPoll()">Start Long Poll</button>
            <button class="btn-stop danger" onclick="stopLongPoll()">Stop Long Poll</button>
            <label for="lpInput">Type here during long polling:</label>
            <input type="text" id="lpInput" placeholder="Smart wait should handle held-open request">
            <div class="log-box" id="log6"></div>
        </div>

        <!-- ===================== SECTION 7: ALL AT ONCE ===================== -->
        <div class="section-card">
            <div class="section-card-header"><h2>7. Kitchen Sink — All Patterns Simultaneously</h2></div>
            <div class="info-box">
                Starts ALL continuous patterns at once: fetch pings + XHR poll + WebSocket +
                SSE + long polling. This is the stress test for smart wait.
            </div>
            <button class="btn-blue" onclick="startAll()">Start ALL</button>
            <button class="btn-stop danger" onclick="stopAll()">Stop ALL</button>
            <label for="kitchenInput">Type here with everything running:</label>
            <input type="text" id="kitchenInput" placeholder="The ultimate smart wait test">
            <button class="btn-blue" id="kitchenBtn">Click Me (all patterns active)</button>
        </div>

    </main>

    <footer class="site-footer">Smart Wait Test Suite &mdash; Continuous &amp; Persistent Connections</footer>

    <script>
        function ts() { return new Date().toLocaleTimeString(); }
        function gid(id) { return document.getElementById(id); }
        function logTo(logId, msg) {
            var d = document.createElement('div');
            d.textContent = ts() + ' ' + msg;
            var el = gid(logId);
            el.insertBefore(d, el.firstChild);
        }

        // ===== 1. Fetch Pings =====
        var fetchPingInterval, fetchPingCount = 0;
        function startFetchPings() {
            stopFetchPings();
            fetchPingCount = 0;
            gid('ping1Status').textContent = 'Active'; gid('ping1Status').className = 'status-badge active';
            fetchPingInterval = setInterval(function() {
                fetchPingCount++;
                gid('ping1Count').textContent = 'Pings sent: ' + fetchPingCount;
                fetch('https://httpbin.org/get?ping=' + fetchPingCount + '&t=' + Date.now(), { mode: 'no-cors' }).catch(function(){});
            }, 500);
            logTo('log1', 'Fetch pings started (every 500ms)');
        }
        function stopFetchPings() {
            clearInterval(fetchPingInterval);
            gid('ping1Status').textContent = 'Stopped'; gid('ping1Status').className = 'status-badge stopped';
            logTo('log1', 'Fetch pings stopped at count ' + fetchPingCount);
        }

        // ===== 2. XHR Polling =====
        var xhrPollInterval, xhrPollCount = 0;
        function startXhrPolling() {
            stopXhrPolling();
            xhrPollCount = 0;
            gid('xhrStatus').textContent = 'Active'; gid('xhrStatus').className = 'status-badge active';
            xhrPollInterval = setInterval(function() {
                xhrPollCount++;
                gid('xhrCount').textContent = 'Polls: ' + xhrPollCount;
                var xhr = new XMLHttpRequest();
                xhr.open('GET', 'https://httpbin.org/get?xhr=' + xhrPollCount + '&t=' + Date.now());
                xhr.send();
            }, 1000);
            logTo('log2', 'XHR polling started (every 1s)');
        }
        function stopXhrPolling() {
            clearInterval(xhrPollInterval);
            gid('xhrStatus').textContent = 'Stopped'; gid('xhrStatus').className = 'status-badge stopped';
            logTo('log2', 'XHR polling stopped at count ' + xhrPollCount);
        }

        // ===== 3. Beacons =====
        var beaconInterval, beaconCount = 0;
        function startBeacons() {
            stopBeacons();
            beaconCount = 0;
            beaconInterval = setInterval(function() {
                beaconCount++;
                gid('beaconCount').textContent = 'Beacons sent: ' + beaconCount;
                try {
                    navigator.sendBeacon('https://httpbin.org/post', 'beacon=' + beaconCount);
                } catch(e) {}
            }, 800);
            logTo('log3', 'Beacons started (every 800ms)');
        }
        function stopBeacons() {
            clearInterval(beaconInterval);
            logTo('log3', 'Beacons stopped at count ' + beaconCount);
        }

        // ===== 4. WebSocket =====
        var ws, wsPingInterval;
        function connectWs() {
            try {
                ws = new WebSocket('wss://ws.postman-echo.com/raw');
                gid('wsStatus').textContent = 'Connecting...'; gid('wsStatus').className = 'status-badge';
                ws.onopen = function() {
                    gid('wsStatus').textContent = 'Connected'; gid('wsStatus').className = 'status-badge active';
                    logTo('log4', 'WebSocket connected');
                    wsPingInterval = setInterval(function() {
                        if (ws && ws.readyState === 1) ws.send('ping-' + Date.now());
                    }, 2000);
                };
                ws.onmessage = function(e) { logTo('log4', 'WS received: ' + e.data); };
                ws.onclose = function() {
                    gid('wsStatus').textContent = 'Disconnected'; gid('wsStatus').className = 'status-badge stopped';
                    clearInterval(wsPingInterval); logTo('log4', 'WebSocket closed');
                };
                ws.onerror = function() { logTo('log4', 'WebSocket error'); };
            } catch(e) { logTo('log4', 'WS connect failed: ' + e.message); }
        }
        function closeWs() { if (ws) ws.close(); clearInterval(wsPingInterval); }
        function sendWsMsg() {
            var v = gid('wsInput').value;
            if (ws && ws.readyState === 1 && v) { ws.send(v); logTo('log4', 'Sent: ' + v); }
        }

        // ===== 5. SSE =====
        var sseSource, sseCount = 0;
        function connectSse() {
            closeSse();
            sseCount = 0;
            try {
                // httpbin doesn't support SSE, so we simulate with a streaming endpoint
                // Using a self-refreshing approach since true SSE servers are limited
                gid('sseStatus').textContent = 'Connected'; gid('sseStatus').className = 'status-badge active';
                logTo('log5', 'SSE simulation started');
                // Simulate SSE with periodic fetch (real SSE would use EventSource)
                sseSource = setInterval(function() {
                    sseCount++;
                    gid('sseCount').textContent = 'Events received: ' + sseCount;
                    fetch('https://httpbin.org/get?sse=' + sseCount, { mode: 'no-cors' }).catch(function(){});
                    logTo('log5', 'SSE event #' + sseCount);
                }, 3000);
            } catch(e) { logTo('log5', 'SSE error: ' + e.message); }
        }
        function closeSse() {
            if (sseSource) clearInterval(sseSource);
            gid('sseStatus').textContent = 'Disconnected'; gid('sseStatus').className = 'status-badge stopped';
            logTo('log5', 'SSE closed');
        }

        // ===== 6. Long Polling =====
        var lpActive = false, lpCount = 0;
        function startLongPoll() {
            lpActive = true; lpCount = 0;
            gid('lpStatus').textContent = 'Active'; gid('lpStatus').className = 'status-badge active';
            logTo('log6', 'Long polling started');
            doPoll();
        }
        function doPoll() {
            if (!lpActive) return;
            lpCount++;
            gid('lpCount').textContent = 'Polls: ' + lpCount;
            logTo('log6', 'Long poll #' + lpCount + ' (5s hold)...');
            fetch('https://httpbin.org/delay/5').then(function(r) { return r.json(); })
                .then(function() {
                    logTo('log6', 'Poll #' + lpCount + ' returned, re-polling...');
                    if (lpActive) doPoll();
                })
                .catch(function() { if (lpActive) setTimeout(doPoll, 1000); });
        }
        function stopLongPoll() {
            lpActive = false;
            gid('lpStatus').textContent = 'Inactive'; gid('lpStatus').className = 'status-badge stopped';
            logTo('log6', 'Long polling stopped');
        }

        // ===== 7. Kitchen Sink =====
        function startAll() {
            startFetchPings(); startXhrPolling(); startBeacons(); connectWs(); connectSse(); startLongPoll();
        }
        function stopAll() {
            stopFetchPings(); stopXhrPolling(); stopBeacons(); closeWs(); closeSse(); stopLongPoll();
        }

        // Auto-start fetch pings on load
        startFetchPings();
    </script>
<!-- INPUT VALUE MONITOR SCRIPT -->
<script>
(function() {
    var eventValue = '';
    var keyLog = [];
    var activeField = null;
    var inputEventFired = false;
    var activeGroup = null;
    var activeGroupLabel = '';

    function getFieldLabel(el) {
        var label = '';
        if (el.id) label = '#' + el.id;
        else if (el.name) label = '[name=' + el.name + ']';
        else if (el.placeholder) label = '"' + el.placeholder.substring(0, 20) + '..."';
        else if (el.className) label = '.' + el.className.split(' ')[0];
        else label = el.tagName.toLowerCase();
        var type = el.getAttribute('type') || el.tagName.toLowerCase();
        return label + ' (' + type + ')';
    }

    function detectGroup(el) {
        if (el.tagName !== 'INPUT') return null;
        if (el.getAttribute('maxlength') !== '1') return null;
        var parent = el.parentElement;
        if (!parent) return null;
        var elClasses = Array.from(el.classList);
        var siblings = Array.from(parent.querySelectorAll('input[maxlength="1"]'));
        if (siblings.length < 2) return null;
        if (elClasses.length === 0) return siblings;
        var group = siblings.filter(function(sib) {
            return elClasses.some(function(cls) { return sib.classList.contains(cls); });
        });
        return group.length >= 2 ? group : null;
    }

    function getGroupLabel(group) {
        if (!group || group.length === 0) return '';
        var first = group[0]; var last = group[group.length - 1];
        var type = 'Group';
        if (first.classList.contains('otp-digit')) type = 'OTP';
        else if (first.classList.contains('pin-digit')) type = 'PIN';
        var firstId = first.id ? '#' + first.id : '?';
        var lastId = last.id ? '#' + last.id : '?';
        return type + ' ' + firstId + ' \u2192 ' + lastId + ' (' + group.length + ' fields)';
    }

    function getGroupValue(group) {
        if (!group) return '';
        return group.map(function(el) { return el.value || '_'; }).join('');
    }

    function isSameGroup(a, b) {
        if (!a || !b) return false;
        if (a.length !== b.length) return false;
        return a[0] === b[0];
    }

    function updateBar() {
        var domVal = activeField ? (activeField.value || activeField.textContent || '') : '';
        document.getElementById('monitorActiveField').textContent = activeField ? getFieldLabel(activeField) : '—';
        document.getElementById('monitorEventValue').textContent = eventValue || '—';
        document.getElementById('monitorDomValue').textContent = domVal || '—';
        document.getElementById('monitorKeyLog').textContent = keyLog.length > 0 ? keyLog.slice(-20).join('') : '—';

        var domValEl = document.getElementById('monitorDomValue');
        var sourceEl = document.getElementById('monitorSource');
        var groupSection = document.getElementById('monitorGroupSection');
        var groupDivider = document.getElementById('monitorGroupDivider');

        if (activeGroup && activeGroup.length > 1) {
            document.getElementById('monitorGroupLabel').textContent = activeGroupLabel;
            document.getElementById('monitorGroupValue').textContent = getGroupValue(activeGroup);
            groupSection.style.display = '';
            groupDivider.style.display = '';
        } else {
            groupSection.style.display = 'none';
            groupDivider.style.display = 'none';
        }

        if (!activeField || (!eventValue && !domVal)) {
            sourceEl.textContent = '—';
            sourceEl.className = 'monitor-source';
            domValEl.className = 'monitor-value';
        } else if (inputEventFired && eventValue === domVal) {
            sourceEl.textContent = 'REAL INPUT';
            sourceEl.className = 'monitor-source source-real';
            domValEl.className = 'monitor-value match';
        } else if (domVal && !inputEventFired) {
            sourceEl.textContent = 'JS INJECTED';
            sourceEl.className = 'monitor-source source-js';
            domValEl.className = 'monitor-value js-injected';
        } else if (eventValue !== domVal) {
            sourceEl.textContent = 'MODIFIED';
            sourceEl.className = 'monitor-source source-js';
            domValEl.className = 'monitor-value js-injected';
        } else {
            sourceEl.textContent = 'REAL INPUT';
            sourceEl.className = 'monitor-source source-real';
            domValEl.className = 'monitor-value match';
        }
    }

    document.addEventListener('focusin', function(e) {
        var tag = e.target.tagName;
        var isEditable = e.target.isContentEditable;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || isEditable) {
            var newGroup = detectGroup(e.target);
            var stayingInGroup = isSameGroup(newGroup, activeGroup);
            activeField = e.target;
            eventValue = e.target.value || e.target.textContent || '';
            if (stayingInGroup) {
                inputEventFired = true;
            } else {
                keyLog = [];
                inputEventFired = false;
                activeGroup = newGroup;
                activeGroupLabel = newGroup ? getGroupLabel(newGroup) : '';
            }
            updateBar();
        }
    }, true);

    document.addEventListener('keydown', function(e) {
        if (!activeField) return;
        var isGroupKey = activeGroup && activeGroup.indexOf(e.target) !== -1;
        if (e.target !== activeField && !isGroupKey && !activeField.contains(e.target)) return;
        var key = e.key;
        if (key === 'Backspace') keyLog.push('\u232b');
        else if (key === 'Enter') keyLog.push('\u21b5');
        else if (key === 'Tab') keyLog.push('\u21e5');
        else if (key === 'Shift' || key === 'Control' || key === 'Alt' || key === 'Meta') { /* skip modifiers */ }
        else if (key.length === 1) keyLog.push(key);
        updateBar();
    }, true);

    document.addEventListener('input', function(e) {
        if (!activeField) return;
        var isGroupInput = activeGroup && activeGroup.indexOf(e.target) !== -1;
        if (e.target !== activeField && !isGroupInput && !activeField.contains(e.target)) return;
        inputEventFired = true;
        eventValue = e.target.value || e.target.textContent || '';
        activeField = e.target;
        updateBar();
    }, true);

    document.addEventListener('change', function(e) {
        if (e.target.tagName === 'SELECT') {
            activeField = e.target;
            activeGroup = null;
            activeGroupLabel = '';
            inputEventFired = true;
            eventValue = e.target.value;
            updateBar();
        }
    }, true);

    setInterval(function() {
        if (activeField) updateBar();
    }, 500);
})();
</script>
<script>
document.getElementById('themeToggle').addEventListener('click', function() {
    var html = document.documentElement;
    var current = html.getAttribute('data-theme') || 'dark';
    var next = current === 'dark' ? 'light' : 'dark';
    html.setAttribute('data-theme', next);
    localStorage.setItem('lt-theme', next);
});
</script>
<script>
(function() {
    var g1 = document.querySelector('.glow-container:not(.glow-2)');
    var g2 = document.querySelector('.glow-container.glow-2');
    if (!g1) return;
    var mx = window.innerWidth / 2, my = window.innerHeight / 2;
    var cx = mx, cy = my, cx2 = mx, cy2 = my;
    g1.style.transform = 'translate(' + (mx - 400) + 'px,' + (my - 400) + 'px)';
    if (g2) g2.style.transform = 'translate(' + (mx - 300) + 'px,' + (my - 300) + 'px)';
    document.addEventListener('mousemove', function(e) { mx = e.clientX; my = e.clientY; });
    (function loop() {
        cx += (mx - cx) * 0.08;
        cy += (my - cy) * 0.08;
        cx2 += (mx - cx2) * 0.035;
        cy2 += (my - cy2) * 0.035;
        g1.style.transform = 'translate(' + (cx - 400) + 'px,' + (cy - 400) + 'px)';
        if (g2) g2.style.transform = 'translate(' + (cx2 - 300) + 'px,' + (cy2 - 300) + 'px)';
        requestAnimationFrame(loop);
    })();
})();
</script>
</body>
</html>
